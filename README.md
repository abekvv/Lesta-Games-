Задание №1
1. Первая реализация (с использованием оператора %) - это классический и наиболее читаемый способ проверки четности числа. Он работает по принципу деления числа на 2 и проверки остатка. Если остаток 0, значит число четное.

def isEven(value):
    return value % 2 == 0

Плюсы:
а. простой и понятный код;
б. используется для большинства задач.

Минусы: 
а. в некоторых случаях может быть чуть медленнее, так как операция деления на 2 более затратна по времени процессора.

2. Вторая реализация (с использованием побитового оператора &) - это побитовая операция & проверяет младший бит числа, который будет равен 0 для четных чисел и 1 для нечетных.

def isEven(value):
    return (value & 1) == 0

Плюсы:
а. потенциально более быстрая, так как битовые операции выполняются быстрее, чем операции деления;
б. эффективно используется для низкоуровневых оптимизаций.

Минусы:
а. меньшая читаемость кода, особенно для людей, не знакомых с побитовыми операциями;
б. меньше переносимости в случаях, когда нужно работать с другими типами данных.


Задание №2
1. Реализация с использованием списка (list).

class FIFOBufferList:
    def __init__(self, size):
        self.size = size
        self.buffer = []

    def add(self, item):
        if len(self.buffer) == self.size:
            self.buffer.pop(0)  
        self.buffer.append(item)

    def get(self):
        if self.buffer:
            return self.buffer.pop(0)
        return None

Плюсы:
а. простота реализации;
б. понятный и легко поддерживаемый код.

Минусы: 
а. операция pop(0) требует сдвига всех оставшихся элементов, что может быть неэффективно, особенно при больших размерах буфера (время работы O(n)).

2. Реализация с использованием deque из модуля collections.

class FIFOBufferDeque:
    def __init__(self, size):
        self.size = size
        self.buffer = deque()

    def add(self, item):
        if len(self.buffer) == self.size:
            self.buffer.popleft() 
        self.buffer.append(item)

    def get(self):
        if self.buffer:
            return self.buffer.popleft()
        return None

Плюсы: 
а. операции append() и popleft() выполняются за O(1), что делает эту реализацию более эффективной, чем с использованием списка;
б. deque оптимизирован для работы с очередями.

Минусы:
а. зависимость от внешней библиотеки collections;
б. немного более сложная реализация, чем с обычным списком.

Сравнение:
Характеристика                   FIFOBufferList (список)            FIFOBufferDeque (deque)                           

Время добавления элемента        O(1) (если не требуется сдвиг)     O(1) (всегда)                                     
Время удаления первого элемента  O(n) (при сдвиге всех элементов)   O(1)                                               
Память                           Использует динамический массив     Более эффективна по памяти для циклической очереди 
Простота использования           Легко и понятно                    Немного сложнее из-за использования deque          


Задание №3
1. Алгоритм для сортировки массива чисел

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

Объяснение:

1. Алгоритм быстрой сортировки:
а. мы выбираем опорный элемент (pivot), в этой реализации опорным элементом является элемент, находящийся в середине массива (индекс len(arr) // 2). Это выбор не является случайным, но он помогает избежать худших случаев, связанных с выбором первого или последнего элемента, как опорного;
б. массив делится на три части:
- left: элементы массива, которые меньше опорного элемента;
- middle: элементы массива, которые равны опорному элементу;
- right: элементы массива, которые больше опорного элемента.
в. рекурсивно сортируются две части массива: left и right, а затем результаты соединяются обратно, начиная с отсортированных левых элементов, опорного элемента и отсортированных правых элементов.

2. Преимущества быстрой сортировки:
а. быстрая сортировка имеет среднюю сложность O(n log n), что делает её одним из самых быстрых алгоритмов сортировки для случайных данных. Это оптимальное время для многих случаев, включая случайные и частично отсортированные данные;
б. этот алгоритм работает эффективно, поскольку при рекурсивной сортировке массивов, разделение на части (left, middle, right) часто приводит к сбалансированным частям, что гарантирует работу за O(n log n);
в. быстрая сортировка обычно работает довольно быстро на больших данных благодаря эффективному разделению массива.

3. Минусы:
а. в худшем случае (например, когда массив отсортирован или частично отсортирован) сложность может составлять O(n²), если опорный элемент выбран неудачно. Это случается, если мы всегда выбираем самый левый, самый правый или центральный элемент в отсортированном массиве;
б. быстрая сортировка — это рекурсивный алгоритм, и при очень больших массивах может возникнуть переполнение стека из-за глубокой рекурсии. Поэтому на практике используется оптимизация с выбором опорного элемента случайным образом или другими методами, чтобы минимизировать вероятность худшего случая.

